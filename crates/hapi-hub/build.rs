use std::fs;
use std::path::Path;
use std::process::Command;

use ts_rs::{Config, TS};

use hapi_shared::modes::*;
use hapi_shared::schemas::*;
use hapi_shared::session_summary::*;

macro_rules! emit {
    ($out:expr, $cfg:expr, $($ty:ty),+ $(,)?) => {
        $({
            let decl = <$ty>::decl($cfg);
            if decl.starts_with("type ") {
                $out.push_str("export ");
            }
            $out.push_str(&decl);
            $out.push('\n');
        })+
    };
}

fn generate_ts_types(types_dir: &Path) {
    fs::create_dir_all(types_dir).expect("Failed to create types directory");

    let dest = types_dir.join("generated.ts");
    let cfg = Config::default();

    let mut output = String::from(
        "// Auto-generated by hapi-hub build.rs. Do not edit.\n\n\
         export type JsonValue = any;\n\n",
    );

    emit!(
        output,
        &cfg,
        PermissionMode,
        ModelMode,
        AgentFlavor,
        PermissionModeTone,
        MetadataSummary,
        WorktreeMetadata,
        Metadata,
        StartedBy,
        AgentStateRequest,
        CompletedRequestStatus,
        PermissionDecision,
        NestedAnswers,
        AnswersFormat,
        AgentStateCompletedRequest,
        AgentState,
        TodoStatus,
        TodoPriority,
        TodoItem,
        AttachmentMetadata,
        DecryptedMessage,
        Session,
        SyncEvent,
        ToastData,
        ConnectionChangedData,
        SummaryText,
        TodoProgress,
        SessionSummaryMetadata,
        SessionSummary,
    );

    // Only write if content changed to avoid unnecessary rebuilds
    let existing = fs::read_to_string(&dest).unwrap_or_default();
    if existing != output {
        fs::write(&dest, &output)
            .unwrap_or_else(|e| panic!("Failed to write {}: {e}", dest.display()));
    }
}

fn main() {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let workspace_root = Path::new(&manifest_dir).parent().unwrap().parent().unwrap();
    let web_dir = workspace_root.join("web");
    let web_dist = web_dir.join("dist");
    let hapi_ts_root = workspace_root.parent().unwrap().join("hapi-ts");

    // generate TS types
    let shared_src = workspace_root.join("crates/hapi-shared/src");
    println!("cargo:rerun-if-changed={}", shared_src.display());
    generate_ts_types(&web_dir.join("src/types"));

    // Only auto-build frontend in release mode
    let profile = std::env::var("PROFILE").unwrap_or_default();
    if profile != "release" {
        println!("cargo:rerun-if-changed={}", web_dist.display());
        return;
    }

    // Rerun if the TS source changes
    let hapi_ts_web_src = hapi_ts_root.join("web/src");
    let hapi_ts_web_pkg = hapi_ts_root.join("web/package.json");
    println!("cargo:rerun-if-changed={}", hapi_ts_web_src.display());
    println!("cargo:rerun-if-changed={}", hapi_ts_web_pkg.display());

    if !hapi_ts_root.join("web/package.json").exists() {
        println!(
            "cargo:warning=hapi-ts project not found at {}. Skipping frontend build.",
            hapi_ts_root.display()
        );
        return;
    }

    // Run bun install + build in hapi-ts root
    println!(
        "cargo:warning=Building frontend from {} ...",
        hapi_ts_root.display()
    );

    let status = Command::new("bun")
        .args(["install"])
        .current_dir(&hapi_ts_root)
        .status()
        .expect("Failed to run `bun install`. Is bun installed?");
    if !status.success() {
        panic!("bun install failed");
    }

    let status = Command::new("bun")
        .args(["run", "build:web"])
        .current_dir(&hapi_ts_root)
        .status()
        .expect("Failed to run `bun run build:web`");
    if !status.success() {
        panic!("bun run build:web failed");
    }

    // Copy dist output to workspace web/dist
    let src_dist = hapi_ts_root.join("web/dist");
    if !src_dist.exists() {
        panic!(
            "Frontend build produced no output at {}",
            src_dist.display()
        );
    }

    fs::create_dir_all(&web_dist).ok();
    copy_dir_recursive(&src_dist, &web_dist).expect("Failed to copy web/dist");
}

fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
    fs::create_dir_all(dst)?;
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let ty = entry.file_type()?;
        let dst_path = dst.join(entry.file_name());
        if ty.is_dir() {
            copy_dir_recursive(&entry.path(), &dst_path)?;
        } else {
            fs::copy(entry.path(), &dst_path)?;
        }
    }
    Ok(())
}
