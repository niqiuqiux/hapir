use std::fs;
use std::path::Path;
use std::process::Command;

use ts_rs::{Config, TS};

use hapir_shared::modes::*;
use hapir_shared::schemas::*;
use hapir_shared::session_summary::*;

macro_rules! emit {
    ($out:expr, $cfg:expr, $($ty:ty),+ $(,)?) => {
        $({
            let decl = <$ty>::decl($cfg);
            if decl.starts_with("type ") {
                $out.push_str("export ");
            }
            $out.push_str(&decl);
            $out.push('\n');
        })+
    };
}

fn generate_ts_types(types_dir: &Path) {
    fs::create_dir_all(types_dir).expect("Failed to create types directory");

    let dest = types_dir.join("generated.ts");
    let cfg = Config::default();

    let mut output = String::from(
        "// Auto-generated by hapir-hub build.rs. Do not edit.\n\n\
         export type JsonValue = any;\n\n",
    );

    emit!(
        output,
        &cfg,
        PermissionMode,
        ModelMode,
        AgentFlavor,
        PermissionModeTone,
        MetadataSummary,
        WorktreeMetadata,
        Metadata,
        StartedBy,
        AgentStateRequest,
        CompletedRequestStatus,
        PermissionDecision,
        NestedAnswers,
        AnswersFormat,
        AgentStateCompletedRequest,
        AgentState,
        TodoStatus,
        TodoPriority,
        TodoItem,
        AttachmentMetadata,
        DecryptedMessage,
        Session,
        SyncEvent,
        ToastData,
        ConnectionChangedData,
        SummaryText,
        TodoProgress,
        SessionSummaryMetadata,
        SessionSummary,
    );

    // Only write if content changed to avoid unnecessary rebuilds
    let existing = fs::read_to_string(&dest).unwrap_or_default();
    if existing != output {
        fs::write(&dest, &output)
            .unwrap_or_else(|e| panic!("Failed to write {}: {e}", dest.display()));
    }
}

fn main() {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let workspace_root = Path::new(&manifest_dir).parent().unwrap().parent().unwrap();
    let web_dir = workspace_root.join("web");
    let web_dist = web_dir.join("dist");

    // generate TS types
    let shared_src = workspace_root.join("crates/hapir-shared/src");
    println!("cargo:rerun-if-changed={}", shared_src.display());
    generate_ts_types(&web_dir.join("src/types"));

    // Only auto-build frontend in release mode
    let profile = std::env::var("PROFILE").unwrap_or_default();
    if profile != "release" {
        println!("cargo:rerun-if-changed={}", web_dist.display());
        return;
    }

    // Rerun if the web source changes
    let web_src = web_dir.join("src");
    let web_pkg = web_dir.join("package.json");
    println!("cargo:rerun-if-changed={}", web_src.display());
    println!("cargo:rerun-if-changed={}", web_pkg.display());

    if !web_pkg.exists() {
        println!(
            "cargo:warning=web/package.json not found at {}. Skipping frontend build.",
            web_pkg.display()
        );
        return;
    }

    // Build frontend from local web/ directory
    println!(
        "cargo:warning=Building frontend from {} ...",
        web_dir.display()
    );

    let bun = find_bun();

    let status = Command::new(&bun)
        .args(["install"])
        .current_dir(&web_dir)
        .status()
        .expect("Failed to run `bun install`. Is bun installed?");
    if !status.success() {
        panic!("bun install failed");
    }

    let status = Command::new(&bun)
        .args(["run", "build"])
        .current_dir(&web_dir)
        .status()
        .expect("Failed to run `bun run build`");
    if !status.success() {
        panic!("bun run build failed");
    }

    if !web_dist.exists() {
        panic!(
            "Frontend build produced no output at {}",
            web_dist.display()
        );
    }
}

/// Locate the `bun` binary. Cargo build scripts may run with a minimal PATH,
/// so we also check common install locations.
fn find_bun() -> String {
    if Command::new("bun").arg("--version").output().is_ok() {
        return "bun".into();
    }
    if let Ok(home) = std::env::var("HOME") {
        let candidate = format!("{home}/.bun/bin/bun");
        if Path::new(&candidate).exists() {
            return candidate;
        }
    }
    panic!("Cannot find `bun`. Install it from https://bun.sh or add it to PATH.");
}
